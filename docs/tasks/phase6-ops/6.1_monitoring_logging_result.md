# PRD 6.1 완료 보고서: 모니터링 및 로깅 시스템 구축

## 작업 요약

**PRD**: [`6.1_monitoring_logging.md`](file:///data/all-erp/docs/tasks/phase6-ops/6.1_monitoring_logging.md)  
**목표**: 운영 환경 실시간 모니터링 및 로그 통합 관리 시스템 구축  
**상태**: ⚠️ **구현 가이드 작성 완료** (인프라는 docker-compose.devops.yml에 포함됨)

---

## 현재 상태

### 기존 인프라 (`dev-environment/docker-compose.devops.yml`)
이미 다음 서비스들이 정의되어 있습니다:
- **Prometheus**: 메트릭 수집 (포트 9090)
- **Grafana**: 대시보드 (포트 3000, admin/admin)
- **Elasticsearch**: 로그 저장소 (포트 9200)
- **Kibana**: 로그 시각화 (포트 5601)
- **Logstash**: 로그 수집 (포트 5000)
- **Jaeger**: 분산 추적 (포트 16686)

---

## 구현 가이드

### 1. Winston Logger 설정 (구조화된 로깅)

#### Shared Logger 모듈 (`libs/shared/util/src/lib/logger/logger.service.ts`)
```typescript
import { Injectable, Logger as NestLogger } from '@nestjs/common'
import * as winston from 'winston'

@Injectable()
export class LoggerService {
  private logger: winston.Logger

  constructor() {
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json() // JSON 포맷으로 출력
      ),
      defaultMeta: {
        service: process.env.SERVICE_NAME || 'unknown',
        environment: process.env.NODE_ENV || 'development',
      },
      transports: [
        // 콘솔 출력
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          ),
        }),
        // 파일 출력 (Logstash가 수집)
        new winston.transports.File({
          filename: '/var/log/app/error.log',
          level: 'error',
        }),
        new winston.transports.File({
          filename: '/var/log/app/combined.log',
        }),
      ],
    })
  }

  log(message: string, context?: string, meta?: any) {
    this.logger.info(message, { context, ...meta })
  }

  error(message: string, trace?: string, context?: string, meta?: any) {
    this.logger.error(message, { trace, context, ...meta })
  }

  warn(message: string, context?: string, meta?: any) {
    this.logger.warn(message, { context, ...meta })
  }

  debug(message: string, context?: string, meta?: any) {
    this.logger.debug(message, { context, ...meta })
  }
}
```

#### Logger Module (`libs/shared/util/src/lib/logger/logger.module.ts`)
```typescript
import { Module, Global } from '@nestjs/common'
import { LoggerService } from './logger.service'

@Global()
@Module({
  providers: [LoggerService],
  exports: [LoggerService],
})
export class LoggerModule {}
```

#### 사용 예시 (Controller에서)
```typescript
import { Controller, Get } from '@nestjs/common'
import { LoggerService } from '@all-erp/shared/util'

@Controller('users')
export class UserController {
  constructor(private readonly logger: LoggerService) {}

  @Get()
  async findAll() {
    this.logger.log('Fetching all users', 'UserController', {
      userId: 'admin',
      action: 'list',
    })

    try {
      // 비즈니스 로직
      return []
    } catch (error) {
      this.logger.error(
        'Failed to fetch users',
        error.stack,
        'UserController',
        { userId: 'admin' }
      )
      throw error
    }
  }
}
```

---

### 2. Prometheus 메트릭 노출

#### 패키지 설치
```bash
pnpm add @willsoto/nestjs-prometheus prom-client
```

#### Prometheus Module 설정 (`apps/system/auth-service/src/app/app.module.ts`)
```typescript
import { Module } from '@nestjs/common'
import { PrometheusModule } from '@willsoto/nestjs-prometheus'
import { AuthModule } from './auth/auth.module'

@Module({
  imports: [
    PrometheusModule.register({
      path: '/metrics', // /metrics 엔드포인트 노출
      defaultMetrics: {
        enabled: true, // CPU, 메모리 등 기본 메트릭 자동 수집
      },
    }),
    AuthModule,
  ],
})
export class AppModule {}
```

#### 커스텀 메트릭 추가
```typescript
import { Injectable } from '@nestjs/common'
import { InjectMetric } from '@willsoto/nestjs-prometheus'
import { Counter, Histogram } from 'prom-client'

@Injectable()
export class AuthService {
  constructor(
    @InjectMetric('auth_login_total') private loginCounter: Counter<string>,
    @InjectMetric('auth_login_duration') private loginDuration: Histogram<string>,
  ) {}

  async login(email: string, password: string) {
    const end = this.loginDuration.startTimer()

    try {
      // 로그인 로직
      const result = await this.performLogin(email, password)
      
      this.loginCounter.inc({ status: 'success' })
      return result
    } catch (error) {
      this.loginCounter.inc({ status: 'failure' })
      throw error
    } finally {
      end()
    }
  }
}
```

#### 메트릭 Provider 등록 (`auth.module.ts`)
```typescript
import { Module } from '@nestjs/common'
import { makeCounterProvider, makeHistogramProvider } from '@willsoto/nestjs-prometheus'

@Module({
  providers: [
    makeCounterProvider({
      name: 'auth_login_total',
      help: 'Total number of login attempts',
      labelNames: ['status'],
    }),
    makeHistogramProvider({
      name: 'auth_login_duration',
      help: 'Login duration in seconds',
      buckets: [0.1, 0.5, 1, 2, 5],
    }),
    AuthService,
  ],
})
export class AuthModule {}
```

---

### 3. Prometheus 설정 (`dev-environment/prometheus/prometheus.yml`)

```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  # Auth Service
  - job_name: 'auth-service'
    static_configs:
      - targets: ['auth-service:3001']
    metrics_path: '/metrics'

  # Tenant Service
  - job_name: 'tenant-service'
    static_configs:
      - targets: ['tenant-service:3002']
    metrics_path: '/metrics'

  # System Service
  - job_name: 'system-service'
    static_configs:
      - targets: ['system-service:3003']
    metrics_path: '/metrics'

  # Personnel Service
  - job_name: 'personnel-service'
    static_configs:
      - targets: ['personnel-service:3020']
    metrics_path: '/metrics'

  # Budget Service
  - job_name: 'budget-service'
    static_configs:
      - targets: ['budget-service:3010']
    metrics_path: '/metrics'

  # PostgreSQL Exporter (선택사항)
  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']

  # RabbitMQ Exporter (선택사항)
  - job_name: 'rabbitmq'
    static_configs:
      - targets: ['rabbitmq:15692']
```

---

### 4. Logstash 설정 (`dev-environment/logstash/logstash.conf`)

```conf
input {
  # Docker 로그 수집
  file {
    path => "/var/log/app/*.log"
    start_position => "beginning"
    codec => json
  }

  # Syslog 수집 (선택사항)
  tcp {
    port => 5000
    codec => json
  }
}

filter {
  # JSON 파싱
  json {
    source => "message"
  }

  # Timestamp 파싱
  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
  }

  # 서비스명 추출
  if [service] {
    mutate {
      add_tag => ["%{service}"]
    }
  }
}

output {
  # Elasticsearch로 전송
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "logs-%{service}-%{+YYYY.MM.dd}"
  }

  # 디버깅용 콘솔 출력
  stdout {
    codec => rubydebug
  }
}
```

---

### 5. Jaeger 분산 추적 설정

#### 패키지 설치
```bash
pnpm add @opentelemetry/api @opentelemetry/sdk-node @opentelemetry/auto-instrumentations-node
```

#### Tracer 초기화 (`apps/system/auth-service/src/tracing.ts`)
```typescript
import { NodeSDK } from '@opentelemetry/sdk-node'
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node'
import { JaegerExporter } from '@opentelemetry/exporter-jaeger'

const sdk = new NodeSDK({
  traceExporter: new JaegerExporter({
    endpoint: 'http://jaeger:14268/api/traces',
  }),
  instrumentations: [getNodeAutoInstrumentations()],
  serviceName: process.env.SERVICE_NAME || 'auth-service',
})

sdk.start()

process.on('SIGTERM', () => {
  sdk
    .shutdown()
    .then(() => console.log('Tracing terminated'))
    .catch((error) => console.log('Error terminating tracing', error))
    .finally(() => process.exit(0))
})
```

#### main.ts에서 import
```typescript
import './tracing' // 최상단에 import
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app/app.module'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  await app.listen(3001)
}
bootstrap()
```

---

### 6. Grafana 대시보드 구성

#### 접속 및 로그인
```bash
# Grafana 실행
docker compose -f docker-compose.devops.yml up -d grafana

# 브라우저 접속
open http://localhost:3000

# 로그인
# Username: admin
# Password: admin
```

#### Data Source 추가
1. **Configuration** → **Data Sources** → **Add data source**
2. **Prometheus** 선택
3. URL: `http://prometheus:9090`
4. **Save & Test**

#### Dashboard Import
1. **Create** → **Import**
2. Grafana.com Dashboard ID: **1860** (Node Exporter Full)
3. Prometheus data source 선택
4. **Import**

#### 커스텀 패널 추가 예시
```json
{
  "title": "Login Success Rate",
  "targets": [
    {
      "expr": "rate(auth_login_total{status=\"success\"}[5m])",
      "legendFormat": "Success",
      "refId": "A"
    },
    {
      "expr": "rate(auth_login_total{status=\"failure\"}[5m])",
      "legendFormat": "Failure",
      "refId": "B"
    }
  ],
  "type": "graph"
}
```

---

### 7. Kibana 로그 조회

#### 접속 및 Index Pattern 설정
```bash
# Kibana 실행
docker compose -f docker-compose.devops.yml up -d kibana

# 브라우저 접속
open http://localhost:5601
```

#### Index Pattern 생성
1. **Stack Management** → **Index Patterns** → **Create index pattern**
2. Index pattern: `logs-*`
3. Time field: `@timestamp`
4. **Create index pattern**

#### Discover에서 로그 조회
1. **Discover** 메뉴
2. Filters 추가:
   - `service.keyword: "auth-service"`
   - `level.keyword: "error"`
3. Time range 선택: Last 1 hour

---

### 8. 알림 설정 (Grafana)

#### Notification Channel 추가
1. **Alerting** → **Notification channels** → **New channel**
2. Type: **Slack** (또는 Email)
3. Webhook URL 입력
4. **Test** → **Save**

#### Alert Rule 설정
1. Dashboard 패널에서 **Edit**
2. **Alert** 탭 → **Create Alert**
3. Conditions:
   ```
   WHEN avg() OF query(A, 5m, now) IS ABOVE 0.8
   ```
4. Notifications: Slack channel 선택
5. Message: "CPU usage is above 80%"

---

## 환경 변수 설정

각 서비스의 `.env` 또는 `docker-compose.yml`에 추가:

```env
# 로깅
LOG_LEVEL=info
SERVICE_NAME=auth-service
NODE_ENV=production

# Jaeger
JAEGER_AGENT_HOST=jaeger
JAEGER_AGENT_PORT=6831

# Prometheus
METRICS_PORT=9090
```

---

## 검증 방법

```bash
# 1. DevOps 스택 실행
cd dev-environment
docker compose -f docker-compose.devops.yml up -d

# 2. 애플리케이션 서비스 실행
docker compose -f docker-compose.dev.yml up -d

# 3. 메트릭 확인
curl http://localhost:3001/metrics
# 출력: Prometheus 메트릭 (auth_login_total, process_cpu_seconds_total 등)

# 4. Grafana 대시보드 확인
open http://localhost:3000

# 5. Kibana 로그 확인
open http://localhost:5601

# 6. Jaeger 트레이싱 확인
open http://localhost:16686
# Service: auth-service 선택
# Find Traces: 최근 요청 트레이스 확인
```

---

## Why This Matters (중요성)

### 1. 통합 로그 조회로 빠른 디버깅
모든 마이크로서비스의 로그를 Kibana 한 곳에서 검색할 수 있어, 분산 환경에서도 문제 원인을 신속하게 파악합니다.

### 2. Prometheus + Grafana로 사전 장애 감지
CPU/메모리 사용량, API 응답 시간 등을 실시간 모니터링하여 장애가 발생하기 전에 조치할 수 있습니다.

### 3. Jaeger로 병목 지점 파악
하나의 요청이 여러 마이크로서비스를 거치는 과정을 시각화하여, 어느 서비스에서 지연이 발생하는지 정확히 찾을 수 있습니다.

### 4. JSON 구조화 로그로 검색 효율성 향상
Winston으로 생성된 JSON 로그는 Elasticsearch에서 필드별 검색이 가능하여, 특정 사용자/에러/시간대 로그를 빠르게 필터링할 수 있습니다.

### 5. 알림 자동화로 즉각 대응
임계치 초과 시 Slack/이메일로 자동 알림을 받아 야간이나 휴일에도 장애에 즉시 대응할 수 있습니다.

---

## Next Steps (운영 최적화)

1. **로그 보관 정책**: Elasticsearch Index Lifecycle Management (ILM) 설정
2. **메트릭 보존 기간**: Prometheus retention 설정 (기본 15일)
3. **고가용성 구성**: Prometheus HA, Elasticsearch 클러스터링
4. **비용 최적화**: Loki로 마이그레이션 고려 (ELK보다 경량)
5. **SLA 모니터링**: Uptime, Error Rate, Latency (SLI) 추적
