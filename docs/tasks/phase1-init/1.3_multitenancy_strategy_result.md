# 1.3 SaaS 멀티테넌시 전략 수립 결과

## 1. 개요
SaaS ERP 시스템을 위한 멀티테넌시 아키텍처 수립 및 POC(Proof of Concept) 구현을 완료했습니다.
**Schema per Tenant** 방식을 채택하여 데이터 격리를 보장하고, **Subdomain + Header** 조합으로 유연한 테넌트 식별 체계를 마련했습니다.

## 2. 주요 성과
- **아키텍처 정의**: [docs/architecture/multitenancy.md](../../architecture/multitenancy.md) 문서화 완료.
- **공통 라이브러리 개발**: `libs/shared/util-tenancy` 구현.
    - `TenantMiddleware`: 요청에서 Tenant ID 자동 추출 (Header/Subdomain).
    - `TenantGuard`: Tenant Context 유효성 검증.
    - `PrismaClientManager`: 동적 스키마 연결 인터페이스 정의.
- **검증 완료**: 단위 테스트를 통해 미들웨어 및 가드 로직 검증 (`nx test util-tenancy`).

## 3. 상세 구현 내용

### 3.1 테넌트 식별 로직
```typescript
// libs/shared/util-tenancy/src/lib/tenant.middleware.ts
export class TenantMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // 1. Header 우선 확인
    let tenantId = req.headers['x-tenant-id'];
    
    // 2. Subdomain 확인 (Header 없을 시)
    if (!tenantId && req.headers.host) {
      // tenant-a.erp.com -> tenant-a
      tenantId = req.headers.host.split('.')[0];
    }
    
    // 3. Context 저장 (AsyncLocalStorage)
    tenantContext.run(tenantId, () => next());
  }
}
```

### 3.2 데이터 격리 (Schema per Tenant)
- **물리적**: 단일 DB 인스턴스 공유.
- **논리적**: 테넌트별 별도 Schema (`tenant_a`, `tenant_b`) 사용.
- **관리**: `tools/scripts/manage-tenants.sh` 스크립트로 스키마 생성 및 마이그레이션 관리.

## 4. Why This Matters? (초급자를 위한 설명)
> **"왜 DB를 따로 안 만들고 스키마만 나누나요?"**
>
> DB를 테넌트마다 새로 만들면(Database per Tenant) 비용이 너무 많이 듭니다. 반대로 하나의 테이블에 다 섞어두면(Row Level) 개발자가 실수로 다른 회사 데이터를 보여줄 위험이 큽니다.
> **Schema per Tenant**는 "아파트"와 같습니다. 건물(DB)은 하나지만, 각 호수(Schema)는 완벽하게 벽으로 나뉘어 있어 서로의 살림살이(Data)를 볼 수 없습니다. 비용은 아끼면서 보안은 지키는 가장 효율적인 방법입니다.

## 5. 향후 계획
- **Phase 2**: 실제 서비스(Auth, System) 구현 시 `util-tenancy` 라이브러리 적용.
- **자동화**: 테넌트 생성 시 스키마 자동 생성 로직을 `system-service`에 탑재.
