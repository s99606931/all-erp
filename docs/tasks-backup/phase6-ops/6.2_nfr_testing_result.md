# PRD 6.2 완료 보고서: 비기능 요건 검증 (NFR Testing)

## 작업 요약

**PRD**: [`6.2_nfr_testing.md`](file:///data/all-erp/docs/tasks/phase6-ops/6.2_nfr_testing.md)  
**목표**: 보안, 성능, 안정성 등 비기능적 요구사항 검증  
**상태**: ⚠️ **구현 가이드 작성 완료** (실제 테스트 실행은 운영팀 작업 필요)

---

## 구현 가이드

### 1. 보안 감사 (Security Audit)

#### 1.1 OWASP ZAP을 이용한 취약점 스캔

##### 설치 및 실행
```bash
# Docker로 OWASP ZAP 실행
docker run -u zap -p 8080:8080 -p 8090:8090 \
  -v $(pwd):/zap/wrk/:rw \
  -t owasp/zap2docker-stable zap.sh \
  -daemon -host 0.0.0.0 -port 8080 \
  -config api.addrs.addr.name=.* \
  -config api.addrs.addr.regex=true

# Web UI 접속
open http://localhost:8080
```

##### 자동 스캔 설정
```bash
# Quick Scan (빠른 스캔)
docker run --rm -v $(pwd):/zap/wrk/:rw \
  owasp/zap2docker-stable zap-baseline.py \
  -t http://localhost:4200 \
  -r zap-report.html

# Full Scan (전체 스캔)
docker run --rm -v $(pwd):/zap/wrk/:rw \
  owasp/zap2docker-stable zap-full-scan.py \
  -t http://localhost:4200 \
  -r zap-full-report.html
```

##### CI/CD 통합 예시 (GitHub Actions)
```yaml
name: Security Scan

on:
  push:
    branches: [main]

jobs:
  zap-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: ZAP Scan
        uses: zaproxy/action-baseline@v0.9.0
        with:
          target: 'http://localhost:4200'
          rules_file_name: '.zap/rules.tsv'
          fail_action: true
```

#### 1.2 Snyk을 이용한 의존성 취약점 검사

```bash
# Snyk CLI 설치
npm install -g snyk

# 인증
snyk auth

# 프로젝트 스캔
cd /data/all-erp
snyk test

# 자동 수정 (가능한 경우)
snyk fix

# HTML 리포트 생성
snyk test --json | snyk-to-html -o snyk-report.html
```

##### package.json에 스크립트 추가
```json
{
  "scripts": {
    "security:check": "snyk test",
    "security:fix": "snyk fix",
    "security:monitor": "snyk monitor"
  }
}
```

#### 1.3 JWT 보안 테스트

##### JWT 조작 시도 스크립트 (`security-tests/jwt-test.js`)
```javascript
const axios = require('axios')

async function testJWTManipulation() {
  const tests = [
    {
      name: '만료된 토큰',
      token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiZXhwIjoxNjAwMDAwMDAwfQ.xxx',
      expectedStatus: 401
    },
    {
      name: '잘못된 서명',
      token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.invalid_signature',
      expectedStatus: 401
    },
    {
      name: '없는 user_id',
      token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5OTk5OTkifQ.xxx',
      expectedStatus: 401
    }
  ]

  for (const test of tests) {
    try {
      const response = await axios.get('http://localhost:3001/api/protected', {
        headers: { Authorization: `Bearer ${test.token}` }
      })
      console.log(`❌ ${test.name}: Expected ${test.expectedStatus}, got ${response.status}`)
    } catch (error) {
      if (error.response?.status === test.expectedStatus) {
        console.log(`✅ ${test.name}: Correctly rejected with ${test.expectedStatus}`)
      } else {
        console.log(`❌ ${test.name}: Unexpected status ${error.response?.status}`)
      }
    }
  }
}

testJWTManipulation()
```

#### 1.4 SQL Injection 방어 검증

Prisma ORM을 사용하므로 기본적으로 방어되지만, 추가 검증:

```typescript
// ❌ 취약한 코드 (사용하지 말 것)
// const users = await prisma.$queryRawUnsafe(`SELECT * FROM users WHERE email = '${email}'`)

// ✅ 안전한 코드 (Prisma 사용)
const users = await prisma.user.findMany({
  where: { email }
})

// ✅ 안전한 Raw Query (Parameterized)
const users = await prisma.$queryRaw`SELECT * FROM users WHERE email = ${email}`
```

---

### 2. 부하 테스트 (Load Testing with k6)

#### 2.1 k6 설치

```bash
# macOS
brew install k6

# Linux
sudo gpg -k
sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
sudo apt-get update
sudo apt-get install k6

# Docker
docker pull grafana/k6
```

#### 2.2 부하 테스트 스크립트

##### 로그인 부하 테스트 (`load-tests/login-test.js`)
```javascript
import http from 'k6/http'
import { check, sleep } from 'k6'

export const options = {
  stages: [
    { duration: '30s', target: 10 },   // Ramp-up to 10 users
    { duration: '1m', target: 100 },   // Stay at 100 users
    { duration: '30s', target: 500 },  // Peak at 500 users
    { duration: '1m', target: 1000 },  // Peak at 1000 users
    { duration: '30s', target: 0 },    // Ramp-down to 0 users
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'],  // 95%의 요청이 500ms 이하
    http_req_failed: ['rate<0.01'],    // 에러율 1% 이하
  },
}

export default function () {
  // 로그인 요청
  const loginPayload = JSON.stringify({
    email: 'test@example.com',
    password: 'password123',
  })

  const loginParams = {
    headers: {
      'Content-Type': 'application/json',
    },
  }

  const loginRes = http.post(
    'http://localhost:3001/api/auth/login',
    loginPayload,
    loginParams
  )

  check(loginRes, {
    'login status is 200': (r) => r.status === 200,
    'login has token': (r) => r.json('access_token') !== undefined,
    'response time < 500ms': (r) => r.timings.duration < 500,
  })

  sleep(1)
}
```

##### CRUD 연산 부하 테스트 (`load-tests/crud-test.js`)
```javascript
import http from 'k6/http'
import { check } from 'k6'

export const options = {
  vus: 100,
  duration: '30s',
}

const BASE_URL = 'http://localhost:3020'

export function setup() {
  // 로그인하여 토큰 획득
  const loginRes = http.post(`${BASE_URL}/api/auth/login`, JSON.stringify({
    email: 'admin@example.com',
    password: 'admin123',
  }), {
    headers: { 'Content-Type': 'application/json' },
  })

  return { token: loginRes.json('access_token') }
}

export default function (data) {
  const params = {
    headers: {
      'Authorization': `Bearer ${data.token}`,
      'Content-Type': 'application/json',
    },
  }

  // GET: 직원 목록 조회
  const listRes = http.get(`${BASE_URL}/api/employees`, params)
  check(listRes, {
    'list status 200': (r) => r.status === 200,
  })

  // POST: 직원 등록
  const createRes = http.post(
    `${BASE_URL}/api/employees`,
    JSON.stringify({
      name: `Employee ${Math.random()}`,
      email: `emp${Math.random()}@example.com`,
      departmentId: 'dept-1',
    }),
    params
  )
  check(createRes, {
    'create status 201': (r) => r.status === 201,
  })

  const employeeId = createRes.json('id')

  // GET: 특정 직원 조회
  http.get(`${BASE_URL}/api/employees/${employeeId}`, params)

  // DELETE: 직원 삭제
  http.del(`${BASE_URL}/api/employees/${employeeId}`, null, params)
}
```

#### 2.3 부하 테스트 실행

```bash
# 기본 실행
k6 run load-tests/login-test.js

# 결과를 JSON으로 저장
k6 run --out json=test-result.json load-tests/login-test.js

# Grafana로 실시간 모니터링
k6 run --out influxdb=http://localhost:8086/k6 load-tests/login-test.js

# Docker로 실행
docker run --rm -i grafana/k6 run - <load-tests/login-test.js
```

#### 2.4 결과 분석

k6 출력 예시:
```
     ✓ login status is 200
     ✓ login has token
     ✓ response time < 500ms

     checks.........................: 100.00% ✓ 3000      ✗ 0
     data_received..................: 1.2 MB  40 kB/s
     data_sent......................: 450 kB  15 kB/s
     http_req_duration..............: avg=87.5ms  min=45ms med=75ms max=450ms p(95)=250ms
     http_req_failed................: 0.00%   ✓ 0         ✗ 1000
     http_reqs......................: 1000    33.33/s
     vus............................: 100     min=10      max=1000
```

---

### 3. 장애 복구 훈련 (Chaos Engineering)

#### 3.1 서비스 장애 시뮬레이션

##### 특정 서비스 강제 종료
```bash
# Auth Service 중단
docker compose stop auth-service

# 다른 서비스 영향 확인
curl -i http://localhost:3002/api/health  # System Service (정상 동작해야 함)
curl -i http://localhost:3020/api/health  # Personnel Service (정상 동작해야 함)

# 로그인 시도 (실패해야 함)
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test"}'
# Expected: Connection refused 또는 502 Bad Gateway

# 서비스 재시작
docker compose start auth-service

# 복구 확인
curl -i http://localhost:3001/api/health
```

#### 3.2 데이터베이스 장애 시뮬레이션

```bash
# PostgreSQL 중단
docker compose stop postgres

# 서비스 반응 확인
curl -i http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test"}'
# Expected: 500 Internal Server Error with appropriate error message

# PostgreSQL 재시작
docker compose start postgres

# 재연결 확인 (Prisma는 자동 재연결)
sleep 5
curl -i http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test"}'
# Expected: 200 OK
```

#### 3.3 네트워크 지연 시뮬레이션

Linux에서 `tc` (traffic control) 사용:

```bash
# 네트워크 인터페이스 확인
ip addr show

# 100ms 지연 추가 (예: eth0 인터페이스)
sudo tc qdisc add dev eth0 root netem delay 100ms

# 지연과 함께 패킷 손실 추가
sudo tc qdisc change dev eth0 root netem delay 100ms loss 1%

# 확인
ping -c 5 google.com

# 지연 제거
sudo tc qdisc del dev eth0 root netem
```

Docker Compose에서 네트워크 설정:

```yaml
services:
  auth-service:
    # ...
    networks:
      default:
        # 네트워크 조건 시뮬레이션은 별도 도구 필요 (pumba, toxiproxy 등)
```

#### 3.4 메모리 부족 시뮬레이션

```bash
# 컨테이너 메모리 제한 설정
docker compose -f docker-compose.dev.yml up -d --scale auth-service=1

# 메모리 제한을 100MB로 설정하여 재시작
docker run --name auth-service-limited \
  --memory="100m" \
  --memory-swap="100m" \
  -p 3001:3001 \
  all-erp/auth-service

# 부하를 주어 메모리 부족 상황 유도
k6 run --vus 1000 --duration 1m load-tests/login-test.js

# OOM (Out of Memory) 로그 확인
docker logs auth-service-limited
```

#### 3.5 Circuit Breaker 동작 확인

Circuit Breaker 구현 (NestJS):

```typescript
import { Injectable } from '@nestjs/common'
import CircuitBreaker from 'opossum'

@Injectable()
export class ResilientService {
  private circuitBreaker: CircuitBreaker

  constructor() {
    this.circuitBreaker = new CircuitBreaker(this.callExternalService, {
      timeout: 3000, // 3초 타임아웃
      errorThresholdPercentage: 50, // 에러율 50% 도달 시 Circuit Open
      resetTimeout: 30000, // 30초 후 Half-Open 시도
    })

    this.circuitBreaker.on('open', () => {
      console.log('Circuit breaker opened!')
    })

    this.circuitBreaker.on('halfOpen', () => {
      console.log('Circuit breaker half-open, trying request...')
    })

    this.circuitBreaker.on('close', () => {
      console.log('Circuit breaker closed!')
    })
  }

  async callExternalService() {
    // 외부 서비스 호출
    const response = await fetch('http://external-service/api')
    return response.json()
  }

  async execute() {
    try {
      return await this.circuitBreaker.fire()
    } catch (error) {
      // Fallback logic
      return { message: 'Service temporarily unavailable' }
    }
  }
}
```

---

### 4. 성능 벤치마크 기준

| 항목 | 목표 | 측정 방법 |
|------|------|-----------|
| **응답 시간** | 평균 < 500ms, P95 < 1s | k6 `http_req_duration` |
| **처리량** | > 100 req/s | k6 `http_reqs` |
| **에러율** | < 1% | k6 `http_req_failed` |
| **동시 사용자** | 최소 100명 지원 | k6 `vus` |
| **CPU 사용률** | < 70% | Grafana/Prometheus |
| **메모리 사용률** | < 80% | Grafana/Prometheus |
| **데이터베이스 연결** | < 50개 동시 연결 | Prisma metrics |

---

### 5. 보안 체크리스트

- [ ] HTTPS만 사용 (운영 환경)
- [ ] JWT Secret은 환경 변수로 관리
- [ ] Rate Limiting 설정 (DDoS 방지)
- [ ] CORS 설정 (특정 도메인만 허용)
- [ ] SQL Injection 방어 (Prisma ORM 사용)
- [ ] XSS 방어 (Input sanitization)
- [ ] CSRF 토큰 (Cookie 기반 인증 시)
- [ ] Helmet.js (보안 헤더 설정)
- [ ] 민감 정보 로그 제외 (비밀번호, 신용카드 등)
- [ ] 의존성 취약점 정기 점검 (Snyk, npm audit)

---

## 검증 방법

```bash
# 1. 보안 스캔
docker run --rm -v $(pwd):/zap/wrk/:rw \
  owasp/zap2docker-stable zap-baseline.py \
  -t http://localhost:4200 \
  -r zap-report.html

# 2. 의존성 취약점
snyk test

# 3. 부하 테스트
k6 run --vus 100 --duration 30s load-tests/login-test.js

# 4. 장애 시뮬레이션
docker compose stop auth-service
curl http://localhost:3002/api/health  # Other services should work
docker compose start auth-service

# 5. Grafana에서 실시간 모니터링
open http://localhost:3000
```

---

## Why This Matters (중요성)

### 1. 보안 감사로 사전 취약점 제거
운영 배포 전 OWASP ZAP과 Snyk으로 알려진 취약점을 미리 찾아 수정하여, 해킹 피해를 예방합니다.

### 2. 부하 테스트로 성능 병목 파악
k6로 실제 사용 환경을 시뮬레이션하여, 어느 API가 느린지, 어느 서비스가 스케일링이 필요한지 미리 파악합니다.

### 3. Chaos Engineering으로 복원력 강화
의도적으로 장애를 발생시켜 시스템이 어떻게 반응하는지 확인하고, Circuit Breaker와 Retry 로직이 제대로 동작하는지 검증합니다.

### 4. 임계치 설정으로 SLA 보장
응답 시간, 에러율, CPU/메모리 사용률에 임계치를 설정하여, 성능 저하 시 조기에 경보를 받고 대응할 수 있습니다.

### 5. CI/CD 통합으로 지속적 검증
보안 스캔과 부하 테스트를 CI/CD 파이프라인에 통합하여, 매번 배포 시 자동으로 검증하고 회귀를 방지합니다.

---

## Next Steps (운영 고도화)

1. **Chaos Mesh 도입**: Kubernetes 환경에서 자동화된 Chaos Engineering
2. **SLA 대시보드**: Uptime, Latency, Error Rate 실시간 모니터링
3. **A/B 테스트**: 성능 개선 사항의 효과 측정
4. **Blue-Green Deployment**: 무중단 배포로 다운타임 제로 달성
5. **정기 보안 감사**: 월 1회 취약점 스캔 및 패치
